Refactoring Methods - Ruby






Що таке рефакторинг?
Рефакторинг — це процес поліпшення внутрішньої структури програмного коду без зміни його зовнішньої поведінки. Він полягає у внесенні змін до коду з метою покращення його читабельності, зрозумілості та підтримуваності, при цьому функціональність програми залишається незмінною.




Яка мета рефакторинга?
Основною метою рефакторингу є підвищення якості коду, що робить його більш зручним для подальшого розвитку та тестування. Під час рефакторингу можуть бути оптимізовані алгоритми, покращена організація класів і методів, видалені дублікати коду або змінені імена змінних на більш зрозумілі. Це дозволяє значно знизити технічний борг і спростити процес внесення змін у майбутньому. 




Чому рефакторинг важливий?
Код без рефакторингу може мати дублювання логіки, погано названі змінні або складні для розуміння структури. 


def calc_salary(emp)
if emp[:role] == 'manager'
salary = emp[:base] * 1.2
bonus = emp[:base] * 0.1
elsif emp[:role] == 'developer'
salary = emp[:base] * 1.1
bonus = emp[:base] * 0.05
else
salary = emp[:base] * 1.15
bonus = emp[:base] * 0.08
end


total = salary + bonus
total += total * 0.1 if emp[:exp] > 5
total
end


e1 = {role: 'manager', base: 5000, exp: 6}
e2 = {role: 'developer', base: 4000, exp: 3}
e3 = {role: 'designer', base: 4500, exp: 7}


puts calc_salary(e1)
puts calc_salary(e2)
puts calc_salary(e3)




Коли потрібно рефакторити код:
1. Код стає важким для розуміння 
2. Часті помилки та ускладнення при зміні 
3. Проблеми з продуктивністю 
4. Дублювання логіки 


~> Порада: Завжди рефакторте код перед тим, як додати нові функції




#1 Self Encapsulate Field
Цей метод інкапсулює доступ до змінної через геттери і сеттери, що покращує контроль за значеннями.




Проблема: Прямий доступ до поля ускладнює контроль змін і може спричиняти некоректні значення.


# До
class Employee
attr accessor :salary
end




Рішення: Інкапсулюємо поле через методи доступу.




# Після
class Employee
def initialize(salary)
@salary = salary
end


def salary
@salary
end


def set_salary(amount)
@salary = amount if amount > 0 # Забезпечуємо коректність значення
end
end




Переваги: Код стає безпечнішим та легше підтримуваним. 








#2 Remove Setting Method
Цей метод забороняє зміну значення змінної після її ініціалізації.




Проблема: Неконтрольована зміна даних може спричинити помилки. 


# До
class Account
attr accessor :balance
end






Рішення: Баланс встановлюється тільки під час створення об' єкта.


# Після
class Account
def initialize(balance)
@balance = balance
end


def balance
@balance
end
end


Переваги: Дані залишаються незмінними, що запобігає потенційним помилкам. 




#3 Encapsulate Collection
Цей метод захищає колекцію від зовнішніх змін. 


Проблема: Масив можна змінювати напряму, що може призвести до некоректних даних. 


# До
class Order
attr accessor :items
end




Рішення: Додаємо методи для безпечного керування колекцією.


Після
class Order
def initialize
@items = []
end


#


def add_item(item)
@items << item
end


def items
@items.dup # Повертаємо копію, щоб уникнути змін ззовні
end
end




Переваги: Гарантує безпечне керування масивом та запобігає неконтрольованим змінам. 




Які є інструменти для рефакторинга?
Для мови програмування Ruby є безліч інструментів, наприклад: RuboCop – це статичний аналізатор коду для Ruby, який може допомогти виявити не тільки стилістичні, але й технічні борги. Reek – інструмент для виявлення "неприємних " кодових запахів (code smells). Він аналізує Ruby-код і пропонує поліпшення для його структури. 




Висновки:
Рефакторинг робить код чистішим і підтримуваним Покращує зрозумілість для інших розробників Запобігає майбутнім проблемам з підтримкою Зменшує ймовірність появи помилок 


Ресурси та джерела
Martin Fowler - Refactoring: Improving the Design of Existing Code Robert C. Martin - Clean Code Kent Beck - Implementation Patterns Official Ruby documentation: ruby-doc.org Додаткові ресурси: Code Refactoring Techniques: refactoring.guru Ruby Style Guide: rubystyle.guide


Посилання на YouTube: https://youtu.be/yNLr42Y7PAA
GitHub репозиторій: https://github.com/NureNikitenkoNikita/arkpz-pzpi-22-6-nikitenko-nikita